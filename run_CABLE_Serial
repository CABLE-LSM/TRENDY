#!/usr/bin/env bash

# Load the relevant modules
module purge
module load use.own
module load conda_concept/analysis3
module load intel-compiler
module load CABLE-run/0.0.1

# This script is called by the run_PseudoParallel.sh script, and executes one of the
# serial tasks which form the larger pseudo-parallel experiment.

# Do not define any variables here, they should be either exported by the master
# run_PseudoParallel.sh or imported from the Config file

# Note that all variables defined by the user are in ALL_CAPS, while all variables 
# handled internally are in SnakeCase.

# RUN and CONFIG are passed as command line parameters from run_PseudoParallel.sh

# Read in the CONFIG data
source ${CONFIG}
RUN=${RUN}

# Set the previous stage to the assigned RESTART_DATA
PreviousStage=${RESTART_DATA}

# Ensure the scripts exits when hitting an error
set -e

# Get the top level directory so we can build the absolute paths
TopDir=$(pwd)

#########################################################################################

function RunSingleStepStage() {
    # Execute a stage running with a single step
    # The parsed arguments are:
    #   - The name of the stage, which points to the correct configuration file and
    #       sets the directory name that the outputs are stored in
    #   - The CLEAN flag
    #
    # For now, we're assuming that "single step" stages are only going to be run once.
    # If at some stage in the future we will need to cycle single step stages, some
    # adjustments will need to be made
    StageName=$1
    CLEAN=$2

    # Clean the existing directoty
    if [[ ${CLEAN} -eq 1 ]] ; then
        printf "Cleaning up ${StageName}/run${RUN} directory.\n"
        rm ${StageName}/run${RUN} -r
    fi

    # Make the directory for the stage, prepare the namelists, and move to the run directory
    mkdir results/${StageName}/run${RUN} -p
    printf "Preparing the namelists for stage: ${StageName}\n"
    # The prepare_stage.py takes the current stage name, the location of the restart
    # directory and the run ID.
    prepare_stage.py ${StageName} ${PreviousStage} -r ${RUN}
    cp namelists/met_names.nml results/${StageName}/run${RUN}/
    cd results/${StageName}/run${RUN}

    # Run the stage
    mkdir -p logs outputs restart
    printf "Running stage: ${StageName}\n"
    #cp ${CABLE_CODE} .
    #./cable > logs/cable_out_log.txt
    printf "Successfully completed stage: ${StageName}\n\n"

    # Rename the PreviousDir to the location of the just completed simulation
    PreviousStage=${TopDir}/results/${StageName}/run${RUN}

    # Move back to the main run directory
    cd ${TopDir}
}

#########################################################################################

function RunMultiStepStage() {
    # Execute a stage running with multiple steps
    # The parsed arguments are
    #   - The names of the steps within the stage, which point to the configuration files
    #   - The number of times to cycle the steps within the stage
    #   - The CLEAN flag

    IFS=',' read -ra StageNames <<< $1
    IFS=',' read -ra StepCounts <<< $2
    CLEAN=$3

    # Clean up the existing directories
    if [[ ${CLEAN} -eq 1 ]] ; then
        # For each sub-stage within the larger stage
        for StageName in "${StageNames[@]}"
        do
            printf "Cleaning up ${StageName}/run${RUN} directory.\n"
            rm ${StageName}/run${RUN} -r
        done
    fi

    # Often we run each substage a different number of times. The outer loop must
    # run the largest number of times.
    MaxCycles=${StepCounts[0]}
    for CycleCount in "${StepCounts[@]}"
    do
        ((CycleCount > MaxCycles)) && MaxCycles=${CycleCount}
    done
    
    # For the number of cycles we have specified
    for CYCLE in $(seq -f "%02g" 1 ${MaxCycles}); do
        
        # For each sub-stage
        for StepIndex in "${!StageNames[@]}"
        do
            # Check whether to run the specified sub-stage
            if [[ ${CYCLE} -le ${StepCounts[${StepIndex}]} ]]; then
                StageName=${StageNames[${StageIndex}]}

                # Make the directory for the cycle of the stage, prepare the namelists and
                # move to the run directory
                mkdir results/${StageName}/run${RUN}/cycle${CYCLE} -p
                printf "Preparing the namelists for stage: ${StageName}, cycle: ${CYCLE}\n"

                # The prepare_stage.py takes the current stage name, the location of 
                # the restart directory and the run ID.
                prepare_stage.py ${StageName} ${PreviousStage} -r ${RUN} -c ${CYCLE}
                cp namelists/met_names.nml results/${StageName}/run${RUN}/cycle${CYCLE}/
                cd results/${StageName}/run${RUN}/cycle${CYCLE}

                # Now run the stage
                mkdir -p logs outputs restart
                printf "Running stage: ${StageName}\n"
                #cp ${CABLE_CODE} .
                #./cable > logs/cable_out_log.txt
                printf "Successfully completed stage: ${StageName}, cycle: ${CYCLE}\n\n"

                # Rename the PreviousDir to the location of the just completed simulation
                PreviousStage=${TopDir}/results/${StageName}/run${RUN}/cycle${CYCLE}

                # Move back to the main run directory
                cd ${TopDir}
            fi
        done
    done
}

#########################################################################################

# Iterate through the stages. This is the entirety of the core run routine, the stages
# are handled by separate functions for single-step and multi-step stages
for StageNumber in ${!RUN_FLAGS[@]}
do
    # Is this run activated?
    if [[ ${RUN_FLAGS[$StageNumber]} -eq 1 ]] ; then

        # Do this stage- check whether it's a single step stage, or a multi-step stage
        # To do this, attempt to turn the entry into an array. If the array has more
        # than one element, it's a multi-step stage
        IFS=',' read -ra StageName <<< ${STAGE_NAMES[${StageNumber}]}

        if [[ ${#StageName[@]} -gt 1 ]] ; then
            # It's a multi-step stage, so call the RunMultiStepStage
            # Seems you can't pass arrays to bash functions, so pass the unmodified string and split it internally
            RunMultiStepStage ${STAGE_NAMES[${StageNumber}]} ${CYCLES_PER_STAGE[${StageNumber}]} $CLEAN
        elif [[ ${#StageName[@]} -eq 1 ]] ; then
            # It's a single-step stage, so call the RunSingleStepStage
            RunSingleStepStage ${STAGE_NAMES[${StageNumber}]} $CLEAN
        else
            printf "Invalid input for a stage name: the stage name is ${STAGE_NAMES[$StageNumber]}"
            exit 1
        fi
    fi
done

